-- Represent logical sentences as torch networks
require 'torch'
require 'nn'
require 'Term'


function get_network(bill, run)
   
   return model
end



-- local term = Term(5)
-- print(term.weight)

-- local next = term:forward()
-- print(next)

-- local grad = torch.Tensor(5):fill(1)

-- term:backward(nil, grad)
-- term:updateParameters(0.1)
-- print(term.weight)

function gradUpdate(mlp, learningRate) 
   local pred = mlp:forward{nil, nil}
   -- local pred = mlp:forward({torch.Tensor(5), torch.Tensor(5)})
   -- local err = criterion:forward(pred, y)
   -- local gradCriterion = criterion:backward(pred, y)
   -- pred = pred[1]
   -- print("Pred:", pred[1])
   mlp:zeroGradParameters()
   local grad = torch.zeros(1)
   if pred[1] < 0 then grad[1] = 1.0 end
   mlp:backward({nil, nil}, grad)
   mlp:updateParameters(learningRate)
   return grad[1]
end


-- Model definition
local bill = Term(5)
local run = Term(5)

-- exists(x, bill(x) & run(x))

local p = nn.ParallelTable()
p:add(bill)
p:add(run)

local model = nn.Sequential()
model:add(p)
model:add(nn.JoinTable(2))

-- conjunction
model_min = nn.Min(2)
model:add(model_min)

-- existance
model:add(nn.Max(1))


print("Initial Bill", bill)
print("Initial run", run)

-- model = get_network(bill, run)
for i=1,10 do
   grad = gradUpdate(model, 0.1)
   print("Grad", grad)
   print("Min", model_min.output)
   if grad <= 0 then break end
end

print("Bill", bill)
print("Run", run)
